{ MSEgui Copyright (c) 2014-2016 by Martin Schreiber

    See the file COPYING.MSE, included in this distribution,
    for details about the copyright.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
}
unit __mla__compilerunit;
interface
//{$internaldebug on}
//{$define mse_debugclass}

uses
 __mla__internaltypes;

procedure __mla__zeropointerar(dest: ppointer; const count: ptrint);
procedure __mla__decrefsize(ref: prefsizeinfoty);
procedure __mla__decrefsizeref(const ref: pprefsizeinfoty);
procedure __mla__increfsize(ref: prefsizeinfoty);
procedure __mla__finirefsize(const ref: pprefsizeinfoty);
procedure __mla__finirefsizear(ref: ppointer; const count: ptrint);

procedure __mla__setlengthdynarray(const ref: pprefsizeinfoty;
                                    const count: int32; const itemsize: int32);
procedure __mla__setlengthstring8(const ref: pprefsizeinfoty;
                                                    const count: int32);
procedure __mla__setlengthstring16(const ref: pprefsizeinfoty;
                                                    const count: int32);
procedure __mla__setlengthstring32(const ref: pprefsizeinfoty;
                                                    const count: int32);
procedure __mla__uniquedynarray(const ref: pprefsizeinfoty;
                                                    const itemsize: int32);
procedure __mla__uniquestring8(const ref: pprefsizeinfoty);
procedure __mla__uniquestring16(const ref: pprefsizeinfoty);
procedure __mla__uniquestring32(const ref: pprefsizeinfoty);

function __mla__string8to16(source: prefsizeinfoty): prefsizeinfoty;
function __mla__string8to32(source: prefsizeinfoty): prefsizeinfoty;
function __mla__string16to8(source: prefsizeinfoty): prefsizeinfoty;
function __mla__string16to32(source: prefsizeinfoty): prefsizeinfoty;
function __mla__string32to8(source: prefsizeinfoty): prefsizeinfoty;
function __mla__string32to16(source: prefsizeinfoty): prefsizeinfoty;

function __mla__compstring8eq(a,b: pointer): bool1;
function __mla__compstring8ne(a,b: pointer): bool1;
function __mla__compstring8gt(a,b: pointer): bool1;
function __mla__compstring8lt(a,b: pointer): bool1;
function __mla__compstring8ge(a,b: pointer): bool1;
function __mla__compstring8le(a,b: pointer): bool1;

function __mla__chartostring8(achar: card8): pointer;
function __mla__chartostring16(achar: card16): pointer;
function __mla__chartostring32(achar: card32): pointer;
function __mla__arraytoopenar(ahigh: int32; adata: pointer): openarrayty;
function __mla__dynarraytoopenar(ref: prefsizeinfoty): openarrayty;
function __mla__lengthdynarray(ref: prefsizeinfoty): int32;
function __mla__lengthopenarray(ref: popenarrayty): int32;
function __mla__lengthstring(ref: prefsizeinfoty): int32;
function __mla__highdynarray(ref: prefsizeinfoty): int32;
function __mla__highopenarray(ref: popenarrayty): int32;
function __mla__highstring(ref: prefsizeinfoty): int32;

function __mla__initclass(const classinfo: classdefinfoty): pointer;
procedure __mla__raise(const data: pointer);
function __mla__personality(version: cint;
             actions: _Unwind_Action;
             exceptionclass: _Unwind_Exception_Class;
             exceptionobject: p_Unwind_Exception;
             context: p_Unwind_Context): _Unwind_Reason_Code;

function _Unwind_RaiseException(
           exception_object: p_Unwind_Exception): _Unwind_Reason_Code; external;
function _Unwind_GetLanguageSpecificData(context: p_Unwind_Context): pointer;
                                                                       external;
function _Unwind_GetIP(context: p_Unwind_Context): pointer; external;
procedure _Unwind_SetIP(context: p_Unwind_Context; new_value: pointer);
                                                                  external;
function _Unwind_GetGR(context: p_Unwind_Context; index: cint): ptrint;
                                                                   external;
procedure _Unwind_SetGR(context: p_Unwind_Context; index: cint;
                                                new_value: ptrint); external;

function _Unwind_GetRegionStart(context: p_Unwind_Context): pointer; external;

implementation
type
 pcard8 = ^card8;
 pcard16 = ^card16;
 pcard32 = ^card32;

procedure __mla__zeropointerar(dest: ppointer; const count: ptrint);
var
 pe: ppointer;
begin
 pe:= dest+count;
 while dest < pe do begin
  dest^:= nil;
  inc(dest);
 end;
end;

//todo: thread safe managed types

procedure __mla__increfsize(ref: prefsizeinfoty);
begin
 if ref <> nil then begin
  dec(ref);
  if ref^.ref.count > 0 then begin
   inc(ref^.ref.count);
  end;
 end;
end;

procedure __mla__decrefsize(ref: prefsizeinfoty);
begin
 if ref <> nil then begin
  dec(ref);
  if ref^.ref.count > 0 then begin
   dec(ref^.ref.count);
   if ref^.ref.count = 0 then begin
    freemem(ref);
   end;
  end;
 end;
end;

procedure __mla__increfsizeref(ref: pprefsizeinfoty);
var
 d: prefsizeinfoty;
begin
 d:= ref^;
 if d <> nil then begin
  dec(d);
  inc(d^.ref.count);
 end;
end;

procedure __mla__decrefsizeref(const ref: pprefsizeinfoty);
var
 d: prefsizeinfoty;
begin
 d:= ref^;
 if d <> nil then begin
  dec(d);
  if d^.ref.count > 0 then begin
   dec(d^.ref.count);
   if d^.ref.count = 0 then begin
    freemem(d);
   end;
  end;
//  ref^:= nil;
 end;
end;

procedure __mla__finirefsize(const ref: pprefsizeinfoty);
var
 d: prefsizeinfoty;
begin
 d:= ref^;
 if d <> nil then begin
  dec(d);
  if d^.ref.count > 0 then begin
   dec(d^.ref.count);
   if d^.ref.count = 0 then begin
    freemem(d);
   end;
  end;
  ref^:= nil;
 end;
end;

procedure __mla__finirefsizear(ref: ppointer; const count: ptrint);
var
 pe: ppointer;
begin
 pe:= ref+count;
 while ref < pe do begin
  __mla__finirefsize(pointer(ref));
  inc(ref);
 end;
end;

procedure __mla__setlengthdynarray(const ref: pprefsizeinfoty;
                                    const count: int32; const itemsize: int32);
var
 s,d: pdynarrayheaderty;
 i1,i2: int32;
begin
 i1:= count*itemsize;
 s:= ref^;
 if s <> nil then begin
  dec(s);
  if s^.ref.count = 1 then begin
   if i1 = 0 then begin
    freemem(s);
    ref^:= nil;
   end
   else begin
    i2:= s^.high+1;
    if count <= i2 then begin
     reallocmem(s,i1+dynarrayallocsize); //new size smaller or same
    end
    else begin
     i2:= i2 * itemsize;
     reallocmem(s,i1+dynarrayallocsize); //bigger
     setmem(@s^.data+i2,i1-i2,0);
    end;
    s^.ref.count:= 1;
    s^.high:= count-1;
    ref^:= @s^.data;
   end;
  end
  else begin
   if i1 = 0 then begin
    freemem(s);
    ref^:= nil;
   end
   else begin
    getmem(d,i1+dynarrayallocsize);
    memcpy(@d^.data,@s^.data,i1);
    i2:= (s^.high+1) * itemsize;
    if i1 > i2 then begin  //new bigger
     setmem(@d^.data+i1,i2-i1,0);
    end;
   end;
   dec(s^.ref.count);
   d^.ref.count:= 1;
   d^.high:= count -1;
   ref^:= @d^.data;
  end;
 end
 else begin
  if count > 0 then begin
   getzeromem(s,i1+dynarrayallocsize);
   s^.ref.count:= 1;
   s^.high:= count-1;
   ref^:= @s^.data;
  end;
 end;
end;

procedure __mla__setlengthstring8(const ref: pprefsizeinfoty;
                                                    const count: int32);
var
 s,d: pstringheaderty;
 i1,i2: int32;
begin
 i1:= count * 1; //bytesize
 s:= ref^;
 if s <> nil then begin
  dec(s);
  if s^.ref.count = 1 then begin
   if i1 = 0 then begin
    freemem(s);
    ref^:= nil;
   end
   else begin
    reallocmem(s,i1+string8allocsize);
    s^.ref.count:= 1;
    s^.len:= count;
    ref^:= @s^.data;
    (pcard8(pointer(s+1))+count)^:= 0; //terminator
   end;
  end
  else begin
   if i1 = 0 then begin
    freemem(s);
    ref^:= nil;
   end
   else begin
    getmem(d,i1+string8allocsize);
    i2:= s^.len * 1; //old bytesize
    if i2 <= i1 then begin
     memcpy(@d^.data,@s^.data,i2);
    end
    else begin
     memcpy(@d^.data,@s^.data,i1);
    end;
    (pcard8(pointer(s+1))+count)^:= 0; //terminator
   end;
   dec(s^.ref.count);
   d^.ref.count:= 1;
   d^.len:= count;
   ref^:= @d^.data;
  end;
 end
 else begin
  if count > 0 then begin
   getmem(s,i1+string8allocsize);
   s^.ref.count:= 1;
   s^.len:= count;
   ref^:= @s^.data;
   (pcard8(pointer(s+1))+count)^:= 0; //terminator
  end;
 end;
end;

procedure __mla__setlengthstring16(const ref: pprefsizeinfoty;
                                                    const count: int32);
var
 s,d: pstringheaderty;
 i1,i2: int32;
begin
 i1:= count * 2; //bytesize
 s:= ref^;
 if s <> nil then begin
  dec(s);
  if s^.ref.count = 1 then begin
   if i1 = 0 then begin
    freemem(s);
    ref^:= nil;
   end
   else begin
    reallocmem(s,i1+string16allocsize);
    s^.ref.count:= 1;
    s^.len:= count;
    ref^:= @s^.data;
    (pcard16(pointer(s+1))+count)^:= 0; //terminator
   end;
  end
  else begin
   if i1 = 0 then begin
    freemem(s);
    ref^:= nil;
   end
   else begin
    getmem(d,i1+string16allocsize);
    i2:= s^.len * 2; //old bytesize
    if i2 <= i1 then begin
     memcpy(@d^.data,@s^.data,i2);
    end
    else begin
     memcpy(@d^.data,@s^.data,i1);
    end;
    (pcard16(pointer(s+1))+count)^:= 0; //terminator
   end;
   dec(s^.ref.count);
   d^.ref.count:= 1;
   d^.len:= count;
   ref^:= @d^.data;
  end;
 end
 else begin
  if count > 0 then begin
   getmem(s,i1+string16allocsize);
   s^.ref.count:= 1;
   s^.len:= count;
   ref^:= @s^.data;
   (pcard16(pointer(s+1))+count)^:= 0; //terminator
  end;
 end;
end;

procedure __mla__setlengthstring32(const ref: pprefsizeinfoty;
                                                    const count: int32);
var
 s,d: pstringheaderty;
 i1,i2: int32;
begin
 i1:= count * 4; //bytesize
 s:= ref^;
 if s <> nil then begin
  dec(s);
  if s^.ref.count = 1 then begin
   if i1 = 0 then begin
    freemem(s);
    ref^:= nil;
   end
   else begin
    reallocmem(s,i1+string32allocsize);
    s^.ref.count:= 1;
    s^.len:= count;
    ref^:= @s^.data;
    (pcard32(pointer(s+1))+count)^:= 0; //terminator
   end;
  end
  else begin
   if i1 = 0 then begin
    freemem(s);
    ref^:= nil;
   end
   else begin
    getmem(d,i1+string32allocsize);
    i2:= s^.len * 4; //old bytesize
    if i2 <= i1 then begin
     memcpy(@d^.data,@s^.data,i2);
    end
    else begin
     memcpy(@d^.data,@s^.data,i1);
    end;
    (pcard32(pointer(s+1))+count)^:= 0; //terminator
   end;
   dec(s^.ref.count);
   d^.ref.count:= 1;
   d^.len:= count;
   ref^:= @d^.data;
  end;
 end
 else begin
  if count > 0 then begin
   getmem(s,i1+string32allocsize);
   s^.ref.count:= 1;
   s^.len:= count;
   ref^:= @s^.data;
   (pcard32(pointer(s+1))+count)^:= 0; //terminator
  end;
 end;
end;


procedure __mla__uniquedynarray(const ref: pprefsizeinfoty;
                                                    const itemsize: int32);
var
 s,d: pdynarrayheaderty;
 i1: int32;
begin
 s:= ref^;
 if s <> nil then begin
  dec(s);
  if s^.ref.count <> 1 then begin
   i1:= (s^.high+1)*itemsize + dynarrayallocsize;
   getmem(d,i1);
   memcpy(d,s,i1);
   dec(s^.ref.count);
   d^.ref.count:= 1;
   ref^:= @d^.data;
  end;
 end;
end;

procedure __mla__uniquestring8(const ref: pprefsizeinfoty);
var
 s,d: pstringheaderty;
 i1: int32;
begin
 s:= ref^;
 if s <> nil then begin
  dec(s);
  if s^.ref.count <> 1 then begin
   i1:= (s^.len)*1 + string8allocsize;
   getmem(d,i1);
   memcpy(d,s,i1);
   if s^.ref.count > 0 then begin
    dec(s^.ref.count);
   end;
   d^.ref.count:= 1;
   ref^:= @d^.data;
  end;
 end;
end;

procedure __mla__uniquestring16(const ref: pprefsizeinfoty);
var
 s,d: pstringheaderty;
 i1: int32;
begin
 s:= ref^;
 if s <> nil then begin
  dec(s);
  if s^.ref.count <> 1 then begin
   i1:= (s^.len)*2 + string16allocsize;
   getmem(d,i1);
   memcpy(d,s,i1);
   if s^.ref.count > 0 then begin
    dec(s^.ref.count);
   end;
   d^.ref.count:= 1;
   ref^:= @d^.data;
  end;
 end;
end;

procedure __mla__uniquestring32(const ref: pprefsizeinfoty);
var
 s,d: pstringheaderty;
 i1: int32;
begin
 s:= ref^;
 if s <> nil then begin
  dec(s);
  if s^.ref.count <> 1 then begin
   i1:= (s^.len)*4 + string32allocsize;
   getmem(d,i1);
   memcpy(d,s,i1);
   if s^.ref.count > 0 then begin
    dec(s^.ref.count);
   end;
   d^.ref.count:= 1;
   ref^:= @d^.data;
  end;
 end;
end;

const
 errorcodepoint = $3f; //?

procedure getcodepoint(var ps: pcard8; const pe: pcard8; 
                                  out ares: card32);
 function checkok(var acodepoint: card32): boolean; //inline;
 var
  c1: card8;
 begin
  result:= false;
  inc(ps);
  if ps >= pe then begin
   acodepoint:= errorcodepoint;
  end
  else begin
   c1:= ps^ - %10000000;
   if c1 > %00111111 then begin
    acodepoint:= errorcodepoint;
   end
   else begin
    acodepoint:= (acodepoint shl 6) or c1;
    result:= true;
   end;
  end;
 end;

begin
 if ps^ < %10000000 then begin   //1 byte
  ares:= ps^;
 end
 else begin
  if ps^ <= %11100000 then begin //2 bytes
   ares:= ps^ and %00011111;
   if checkok(ares) then begin
    if ares < %1000000 then begin
     ares:= errorcodepoint; //overlong
    end;
   end;
  end
  else begin
   if ps^ < %11110000 then begin //3 bytes
    ares:= ps^ and %00001111;
    if checkok(ares) and checkok(ares) then begin
     if ares < %100000000000 then begin
      ares:= errorcodepoint; //overlong
     end;
    end;
   end
   else begin
    if ps^ < %11111000 then begin //4 bytes
     ares:= ps^ and %00000111;
     if checkok(ares) and checkok(ares) and checkok(ares) then begin
      if ares < %10000000000000000 then begin
       ares:= errorcodepoint; //overlong
      end;
     end;
    end
    else begin
     ares:= errorcodepoint;
    end;
   end;
  end;
 end;
 inc(ps);
 if (ares >= $d800) and (ares <= $dfff) then begin
  ares:= errorcodepoint; //surrogate
 end;
end;

function getcodepoint(var ps: pcard16; const pe: pcard16; 
                                  out ares: card32): boolean;
begin
 result:= true;
 ares:= ps^;
 inc(ps);
 if ares and $fc00 = $d800 then begin
  ares:= (ares - $d800) shl 10;
  if ps < pe then begin 
   ares:= ares + ps^ - $dc00 + $10000;
   inc(ps);
   if ares < $10000 then begin
    ares:= errorcodepoint; //overlong
   end;
  end
  else begin
   ares:= errorcodepoint; //missing surrogate
  end;
 end;
 if (ares >= $d800) and (ares <= $dfff) then begin
  ares:= errorcodepoint; //surrogate pair
 end;
end;

procedure setutf8(const codepoint: card32; var dest: pcard8);
begin
 if codepoint < $80 then begin
  dest^:= codepoint;
 end
 else begin
  if codepoint < $800 then begin //2 byte
   dest^:= (codepoint shr 6) or %11000000;
   inc(dest);
   dest^:= codepoint and %00111111 or %10000000;
  end
  else begin
   if codepoint < $10000 then begin //3 byte
    dest^:= (codepoint shr 12) or %11100000;
    inc(dest);
    dest^:= (codepoint shr 6) and %00111111 or %10000000;
    inc(dest);
    dest^:= codepoint and %00111111 or %10000000;
   end
   else begin                       //4 byte
    dest^:= (codepoint shr 18) or %11110000;
    inc(dest);
    dest^:= (codepoint shr 12) and %00111111 or %10000000;
    inc(dest);
    dest^:= (codepoint shr 6) and %00111111 or %10000000;
    inc(dest);
    dest^:= codepoint and %00111111 or %10000000;
   end;
  end;
 end;
 inc(dest);
end;

function __mla__string8to16(source: prefsizeinfoty): prefsizeinfoty;
begin
end;

function __mla__string8to32(source: prefsizeinfoty): prefsizeinfoty;
begin
end;

function __mla__string16to8(source: prefsizeinfoty): prefsizeinfoty;
var
 pss,pds: pstringheaderty;
 p1,pe: pcard16;
 p2,p3: pcard8;
 c1: card32;
begin
 pss:= source;
 if pss <> nil then begin
  p1:= pointer(pss);
  dec(pss); //header
  pe:= p1+pss^.len;
  getmem(pds,string8allocsize+pss^.len*3); //max 
                                            //todo: use less memory
  p2:= pointer(pds+1);
  p3:= p2;
  while p1 < pe do begin
   getcodepoint(p1,pe,c1);
   setutf8(c1,p2);
  end;
  p2^:= 0;
  pds^.ref.count:= 1;
  pds^.len:= p2-p3;
  inc(pds); //data
  if pss^.ref.count > 0 then begin
   dec(pss^.ref.count);
   if pss^.ref.count = 0 then begin
    freemem(pss);
   end;
  end;
 end
 else begin
  pds:= nil;
 end;
 result:= pds;
end;

function __mla__string16to32(source: prefsizeinfoty): prefsizeinfoty;
begin
end;

function __mla__string32to8(source: prefsizeinfoty): prefsizeinfoty;
begin
end;

function __mla__string32to16(source: prefsizeinfoty): prefsizeinfoty;
begin
end;

function compstring8(a,b:pointer): stringsizety; //a and b <> nil
var
 poa,poe,pob: pcard8;
 la,lb: stringsizety;
 i1: int16;
begin
 la:= (pstringheaderty(a)-1)^.len;
 lb:= (pstringheaderty(b)-1)^.len;
 poa:= a;
 pob:= b;
 if la < lb then begin
  poe:= poa + la;
 end
 else begin
  poe:= poa + lb;
 end;
 while true do begin
  i1:= poa^ - pob^;
  if i1 <> 0 then begin
   result:= i1;
   exit;
  end;
  inc(poa);
  if poa >= poe then begin
   break;
  end;
  inc(pob);
 end;
 result:= la - lb; //cut text equal, compare length
end;

function __mla__compstring8eq(a,b: pointer): bool1;
begin
 result:= a = b;
 if not result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring8(a,b) = 0;
  end
  else begin
   result:= false;
  end;
 end;
end;

function __mla__compstring8ne(a,b: pointer): bool1;
begin
 result:= a <> b;
 if result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring8(a,b) <> 0;
  end
  else begin
   result:= true;
  end;
 end;
end;

function __mla__compstring8gt(a,b: pointer): bool1;
begin
 result:= compstring8(a,b) > 0;
end;

function __mla__compstring8lt(a,b: pointer): bool1;
begin
 result:= compstring8(a,b) < 0;
end;

function __mla__compstring8ge(a,b: pointer): bool1;
begin
 result:= compstring8(a,b) >= 0;
end;

function __mla__compstring8le(a,b: pointer): bool1;
begin
 result:= compstring8(a,b) <= 0;
end;

function __mla__chartostring8(achar: card8): pointer;
var
 po1: pstringheaderty;
begin
 getmem(po1,1*1+string8allocsize);
 po1^.len:= 1;
 po1^.ref.count:= 1;
 result:= po1+1; //data
 pcard8(result)^:= achar;
 (pcard8(result)+1)^:= 0; //terminator
end;

function __mla__chartostring16(achar: card16): pointer;
var
 po1: pstringheaderty;
begin
 getmem(po1,1*2+string16allocsize);
 po1^.len:= 1;
 po1^.ref.count:= 1;
 result:= po1+1; //data
 pcard16(result)^:= achar;
 (pcard16(result)+1)^:= 0; //terminator
end;

function __mla__chartostring32(achar: card32): pointer;
var
 po1: pstringheaderty;
begin
 getmem(po1,1*4+string32allocsize);
 po1^.len:= 1;
 po1^.ref.count:= 1;
 result:= po1+1; //data
 pcard32(result)^:= achar;
 (pcard32(result)+1)^:= 0; //terminator
end;

function __mla__arraytoopenar(ahigh: int32; adata: pointer): openarrayty;
begin
 result.high:= ahigh;
 result.data:= adata;
end;

function __mla__dynarraytoopenar(ref: prefsizeinfoty): openarrayty;
begin
 if ref = nil then begin
  result.high:= -1;
 end
 else begin
  result.high:= pdynarrayheaderty(ref-1)^.high;
 end;
 result.data:= ref;
end;

function __mla__lengthdynarray(ref: prefsizeinfoty): int32;
begin
 if ref <> nil then begin
  result:= pdynarrayheaderty(ref-1)^.high + 1;
 end
 else begin
  result:= 0;
 end;
end;

function __mla__lengthopenarray(ref: popenarrayty): int32;
begin
 result:= ref^.high+1;
end;

function __mla__lengthstring(ref: prefsizeinfoty): int32;
begin
 if ref <> nil then begin
  result:= pstringheaderty(ref-1)^.len;
 end
 else begin
  result:= 0;
 end;
end;

function __mla__highdynarray(ref: prefsizeinfoty): int32;
begin
 if ref <> nil then begin
  result:= pdynarrayheaderty(ref-1)^.high;
 end
 else begin
  result:= -1;
 end;
end;

function __mla__highopenarray(ref: popenarrayty): int32;
begin
 result:= ref^.high;
end;


function __mla__highstring(ref: prefsizeinfoty): int32;
begin
 if ref <> nil then begin
  result:= pstringheaderty(ref-1)^.len;
 end
 else begin
  result:= 0;
 end;
end;

//todo: use simplified version if there are no interfaces
function __mla__initclass(const classinfo: classdefinfoty): pointer;
var
 ps,pd,pe: ppointer;
 po1: pclassdefinfoty;
begin
 getzeromem(result,classinfo.header.allocs.size);
 po1:= @classinfo;
 ppointer(result)^:= @classinfo;
{$ifdef mse_debugclass}
 writeln('***initclass ',result);
{$endif}
 repeat
  pd:= result + po1^.header.allocs.instanceinterfacestart;
                                            //copy interface table
  pe:= result + po1^.header.allocs.size;
  ps:= pointer(po1) + po1^.header.allocs.classdefinterfacestart;
 {$ifdef mse_debugclass}
  writeln(' *classdef:',po1);
  writeln('  parentclass:',po1^.header.parentclass);
  writeln('  interfaceparent:',po1^.header.interfaceparent);
  writeln('  allocs.size:',po1^.header.allocs.size);
  writeln('  interfacestart:',po1^.header.allocs.instanceinterfacestart);
  writeln('  classdefinterfacestart:',po1^.header.allocs.classdefinterfacestart);
 {$endif}
  while pd < pe do begin
   pd^:= ps^;
  {$ifdef mse_debugclass}
   writeln('  intf:',int32(pointer(pd)-result),' ',pd,'^:',pd^,
                 ' instanceoffset:',pintfdefinfoty(pd^)^.header.instanceoffset);
  {$endif}
   inc(pd);
   inc(ps);
  end;
  po1:= po1^.header.interfaceparent;
 until po1 = nil;
end;

procedure exceptioncleanup(reason: _Unwind_Reason_Code;
                                                      exc: p_Unwind_Exception);
begin
 freemem(exc);
end;

procedure __mla__raise(const data: pointer);
var
 po1: pexceptinfoty;
begin  //todo: handle out of memory situation
 getmem(po1,sizeof(exceptinfoty));
 with po1^.header do begin
  exception_class:= mlaexceptionid;
  exception_cleanup:= @exceptioncleanup;
 end;
 po1^.data:= data;
 _Unwind_RaiseException(@po1^.header);
 freemem(po1);
 exitcode:= exco_unhandledexception; //no handler found
 halt();
end;

function readusleb128(var adata: pointer): ptrint;
var
 po1: pcard8;
 shift,i1: int32;
begin
 po1:= adata;
 result:= po1^ and $7f;
 shift:= 7;
 while po1^ and $80 <> 0 do begin       //todo: overflow check
  inc(po1);
  result:= result or ptrint(po1^ and $7f) shl shift;
  shift:= shift + 7;
 end;
 adata:= po1+1;
end;

function readssleb128(var adata: pointer): ptrint;
var
 po1: pcard8;
 shift,i1: int32;
begin
 po1:= adata;
 result:= po1^ and $7f;
 shift:= 7;
 while po1^ and $80 <> 0 do begin       //todo: overflow check
  inc(po1);
  result:= result or ptrint(po1^ and $7f) shl shift;
  shift:= shift + 7;
 end;
 if po1^ and $40 <> 0 then begin   //sign
  result:= result or ptrint(-1) shl shift; //negative
 end;
 adata:= po1+1;
end;

procedure fatalerror();
begin
 writeln('Fatal error');
 halt();
end;

const
{$ifdef target_x86_64}
 exceptionregno = 0;
 selectorregno = 1;
{$else}
 exceptionregno = 0;
 selectorregno = 2;
{$endif}

function installfinallycontext(const actions: _Unwind_Action;
             const exceptiondata: p_Unwind_Exception;
             const context: p_Unwind_Context;
             const landingpad: pointer): _Unwind_Reason_Code;
begin
 if actions and _UA_SEARCH_PHASE <> 0 then begin
  result:= _URC_HANDLER_FOUND;
 end
 else begin
  if actions and _UA_HANDLER_FRAME <> 0 then begin
   _Unwind_SetGR(context,exceptionregno,ptrint(exceptiondata));
   _Unwind_SetGR(context,selectorregno,0);
   _Unwind_SetIP(context,landingpad);
   result:= _URC_INSTALL_CONTEXT;
  end
  else begin
   result:= _URC_CONTINUE_UNWIND;
  end;
 end;
end;

function __mla__personality(version: cint;
             actions: _Unwind_Action;
             exceptionclass: _Unwind_Exception_Class;
             exceptionobject: p_Unwind_Exception;
             context: p_Unwind_Context): _Unwind_Reason_Code;
var
 po1: pointer;
 c1: ptrcard;
 typebaseoffset: ptrcard;
 tablelength: ptrcard;
 actionoffset: ptrcard;
 bo1: bool1;
 typestable: pointer;
 callsitetable: pointer;
 actiontable: pointer;
 ip,regionstart: pointer;
begin
 result:= _URC_CONTINUE_UNWIND;
// if actions and _UA_SEARCH_PHASE <> 0 then begin
 po1:= _Unwind_GetLanguageSpecificData(context);
 if po1 <> nil then begin
  result:= _URC_CONTINUE_UNWIND;
  bo1:= false;
  if pcard8(po1)^ = $ff then begin
   inc(po1);
   if pcard8(po1)^ = 0 then begin
    inc(po1);
    c1:= readusleb128(po1);
    typestable:= po1 + c1;
//writeln(c1);
    if pcard8(po1)^ = 3 then begin
     inc(po1);
     c1:= readusleb128(po1);
//writeln(c1);
     callsitetable:= po1;
     actiontable:= po1 + c1;
     ip:= _Unwind_GetIP(context){-1};
     regionstart:= _Unwind_GetRegionStart(context);
//writeln('IP            ',ip);
//writeln('regionstart   ',regionstart);
//writeln('typestable    ',typestable);
//writeln('callsitetable ',callsitetable);
//writeln('actiontable   ',actiontable);
//writeln('----');
     while callsitetable < actiontable do begin
      po1:= regionstart + pptrint(callsitetable)^;    //blockstart
//writeln(' blockstart   ',po1);
      if po1 > ip then begin
       break;                //no region found
      end;
      po1:= po1 + (pptrint(callsitetable)+1)^;          //blockend
//writeln(' blockend   ',po1);
      if po1 >= ip then begin //region found
       po1:= regionstart + (pptrint(callsitetable)+2)^; //landing pad
//writeln(' landingpad   ',po1);
       inc(callsitetable,3*sizeof(ptrint));
       actionoffset:= readusleb128(callsitetable);
       if actionoffset = 0 then begin
        result:= installfinallycontext(actions,exceptionobject,context,po1);
       end;
       break;
      end
      else begin
       inc(callsitetable,3*sizeof(ptrint));
       readusleb128(callsitetable);
      end;
     end;
     bo1:= true;
    end;
   end;
  end;
  if not bo1 then begin
   fatalerror();
  end;
 end
 else begin
 end;
// end
// else begin
//  if actions and _UA_HANDLER_FRAME <> 0 then begin
//   result:= _URC_INSTALL_CONTEXT;
//  end;
// end;
end;

end.
