//__mla__compilerunit
{ MSEgui Copyright (c) 2014-2018 by Martin Schreiber

    See the file COPYING.MSE, included in this distribution,
    for details about the copyright.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
}
{$mode pascal}
unit __mla__compilerunit;
interface
//{$internaldebug on}
//{$define mse_debugclass}

uses
 __mla__personality,__mla__internaltypes;
procedure __mla__zeropointerar(dest: ppointer; const count: ptrint);
procedure __mla__decrefsize(ref: pointer);
procedure __mla__decrefsizeref(const ref: ppointer);
procedure __mla__increfsize(ref: pointer);
procedure __mla__increfsizeref(ref: ppointer);
procedure __mla__finirefsize(const ref: ppointer);
procedure __mla__finirefsizear(ref: ppointer; const count: ptrint);
procedure __mla__finirefsizedynar(const ref: ppointer);
procedure __mla__storenildynar(const dest: pointer);

procedure __mla__setlengthdynarray(const ref: ppointer;
                                    const count: int32; const itemsize: int32);
procedure __mla__setlengthstring8(const ref: ppointer;
                                                    const count: int32);
procedure __mla__setlengthstring16(const ref: ppointer;
                                                    const count: int32);
procedure __mla__setlengthstring32(const ref: ppointer;
                                                    const count: int32);
procedure __mla__uniquedynarray(const ref: ppointer;
                                                    const itemsize: int32);
procedure __mla__uniquestring8(const ref: ppointer);
procedure __mla__uniquestring16(const ref: ppointer);
procedure __mla__uniquestring32(const ref: ppointer);

function __mla__string8to16(source: pointer): pointer;
function __mla__string8to32(source: pointer): pointer;
function __mla__string16to8(source: pointer): pointer;
function __mla__string16to32(source: pointer): pointer;
function __mla__string32to8(source: pointer): pointer;
function __mla__string32to16(source: pointer): pointer;
function __mla__concatstring8(count: int32;
                                   strings: ppointer): pointer;
function __mla__concatstring16(count: int32;
                                   strings: ppointer): pointer;
function __mla__concatstring32(count: int32;
                                   strings: ppointer): pointer;

function __mla__compstring8eq(a,b: pointer): bool1;
function __mla__compstring8ne(a,b: pointer): bool1;
function __mla__compstring8gt(a,b: pointer): bool1;
function __mla__compstring8lt(a,b: pointer): bool1;
function __mla__compstring8ge(a,b: pointer): bool1;
function __mla__compstring8le(a,b: pointer): bool1;

function __mla__compstring16eq(a,b: pointer): bool1;
function __mla__compstring16ne(a,b: pointer): bool1;
function __mla__compstring16gt(a,b: pointer): bool1;
function __mla__compstring16lt(a,b: pointer): bool1;
function __mla__compstring16ge(a,b: pointer): bool1;
function __mla__compstring16le(a,b: pointer): bool1;


function __mla__compstring32eq(a,b: pointer): bool1;
function __mla__compstring32ne(a,b: pointer): bool1;
function __mla__compstring32gt(a,b: pointer): bool1;
function __mla__compstring32lt(a,b: pointer): bool1;
function __mla__compstring32ge(a,b: pointer): bool1;
function __mla__compstring32le(a,b: pointer): bool1;

function __mla__chartostring8(achar: card8): pointer;
function __mla__chartostring16(achar: card16): pointer;
function __mla__chartostring32(achar: card32): pointer;
procedure __mla__arraytoopenar(ahigh: int32; adata: pointer;
                                      out result: openarrayty);
procedure __mla__dynarraytoopenar(ref: pointer; out result: openarrayty);
function __mla__lengthdynarray(ref: pointer): int32;
function __mla__lengthopenarray(ref: popenarrayty): int32;
function __mla__lengthstring(ref: pointer): int32;
function __mla__highdynarray(ref: pointer): int32;
function __mla__highopenarray(ref: popenarrayty): int32;
function __mla__highstring(ref: pointer): int32;

procedure __mla__initobject(const instance: pointer;
                                        const classinfo: classdefinfoty);
//procedure __mla__calliniobject(const instance: pointer;
//                                        const classinfo: classdefinfoty);
function __mla__getclassdef(const instance: pointer; 
                                const virttaboffset: int32): pointer;
function __mla__getallocsize(const classdef: pclassdefinfoty): int32;
function __mla__classis(const a,b: pclassdefinfoty): bool1;
function __mla__checkclasstype(var instance: pointer; //nil if no match
                              const classtype: pclassdefinfoty): bool1;
                                                      //false if no match
procedure __mla__writeenum(const avalue: int32;
                              const artti: penumrttity);
                              
//function __mla__initclass(const classinfo: classdefinfoty): pointer;
//procedure __mla__finiclass(const instance: pointer);
procedure __mla__raise(const data: pointer);
procedure __mla__finiexception(const data: pointer);

procedure __mla__int32tovarrecty(const value: int32; const res: pvarrecty);

implementation
//uses
// __mla__personality;
const
 temprefcount = 1;
type
 pcard8 = ^card8;
 pcard16 = ^card16;
 pcard32 = ^card32;

procedure __mla__zeropointerar(dest: ppointer; const count: ptrint);
var
 pe: ppointer;
begin
 pe:= dest+count;
 while dest < pe do begin
  dest^:= nil;
  inc(dest);
 end;
end;

//todo: thread safe managed types

procedure __mla__increfsize(ref: pointer);
var
 d: prefsizeinfoty;
begin
 d:= ref;
 if d <> nil then begin
  dec(d);
  if d^.ref.count >= 0 then begin
   inc(d^.ref.count);
  end;
 end;
end;

procedure __mla__decrefsize(ref: pointer);
var
 d: prefsizeinfoty;
begin
 d:= ref;
 if d <> nil then begin
  dec(d);
  if d^.ref.count > 0 then begin
   dec(d^.ref.count);
  end;
  if d^.ref.count = 0 then begin
   freemem(d);
  end;
 end;
end;

procedure __mla__increfsizeref(ref: ppointer);
var
 d: prefsizeinfoty;
begin
 d:= ref^;
 if d <> nil then begin
  dec(d);
  if d^.ref.count >= 0 then begin
   inc(d^.ref.count);
  end;
 end;
end;

procedure __mla__decrefsizeref(const ref: ppointer);
var
 d: prefsizeinfoty;
begin
 d:= ref^;
 if d <> nil then begin
  dec(d);
  if d^.ref.count > 0 then begin
   dec(d^.ref.count);
  end;
  if d^.ref.count = 0 then begin
   freemem(d);
  end;
//  ref^:= nil;
 end;
end;

procedure __mla__finirefsize(const ref: ppointer);
var
 d: prefsizeinfoty;
begin
 d:= ref^;
 if d <> nil then begin
  dec(d);
  if d^.ref.count > 0 then begin
   dec(d^.ref.count);
  end;
  if d^.ref.count = 0 then begin
   freemem(d);
  end;
  ref^:= nil;
 end;
end;

procedure __mla__finirefsizear(ref: ppointer; const count: ptrint);
var
 pe: ppointer;
begin
 pe:= ref+count;
 while ref < pe do begin
  __mla__finirefsize(pointer(ref));
  inc(ref);
 end;
end;

procedure __mla__finirefsizedynar(const ref: ppointer);
var
 d: pdynarrayheaderty;
 p1,pe: ppointer;
begin
 p1:= ref^;
 if p1 <> nil then begin
  d:= pdynarrayheaderty(p1)-1;
  pe:= p1+d^.high;
  while p1 <= pe do begin
   __mla__finirefsize(p1);
   inc(p1);
  end;
  if d^.ref.count > 0 then begin
   dec(d^.ref.count);
  end;
  if d^.ref.count = 0 then begin
   freemem(d);
  end;
  ref^:= nil;
 end;
end;

procedure __mla__storenildynar(const dest: pointer);
var
 p1,pe: ppointer;
begin
 p1:= dest;
 if p1 <> nil then begin
  pe:= p1+(pdynarrayheaderty(dest)-1)^.high;
  while p1 <= pe do begin
   p1^:= nil;
   inc(p1);
  end;
 end;
end;

procedure __mla__setlengthdynarray(const ref: ppointer;
                                    const count: int32; const itemsize: int32);
var
 s,d: pdynarrayheaderty;
 i1,i2: int32;
begin
 i1:= count*itemsize;
 s:= ref^;
 if s <> nil then begin
  dec(s);
  if s^.ref.count = 1 then begin
   if i1 = 0 then begin
    freemem(s);
    ref^:= nil;
   end
   else begin
    i2:= s^.high+1;
    if count <= i2 then begin
     reallocmem(s,i1+dynarrayallocsize); //new size smaller or same
    end
    else begin
     i2:= i2 * itemsize;
     reallocmem(s,i1+dynarrayallocsize); //bigger
     setmem(@s^.data+i2,i1-i2,0);
    end;
    s^.ref.count:= 1;
    s^.high:= count-1;
    ref^:= @s^.data;
   end;
  end
  else begin
   if i1 = 0 then begin
    freemem(s);
    ref^:= nil;
   end
   else begin
    d:= getmem(i1+dynarrayallocsize);
    memcpy(@d^.data,@s^.data,i1);
    i2:= (s^.high+1) * itemsize;
    if i1 > i2 then begin  //new bigger
     setmem(@d^.data+i1,i2-i1,0);
    end;
   end;
   dec(s^.ref.count);
   d^.ref.count:= 1;
   d^.high:= count -1;
   ref^:= @d^.data;
  end;
 end
 else begin
  if count > 0 then begin
   s:= getzeromem(i1+dynarrayallocsize);
   s^.ref.count:= 1;
   s^.high:= count-1;
   ref^:= @s^.data;
  end;
 end;
end;

procedure __mla__setlengthstring8(const ref: ppointer; const count: int32);
var
 s,d: pstringheaderty;
 i1,i2: int32;
begin
 i1:= count * 1; //bytesize
 s:= ref^;
 if s <> nil then begin
  dec(s);
  if s^.ref.count = 1 then begin
   if i1 = 0 then begin
    freemem(s);
    ref^:= nil;
   end
   else begin
    reallocmem(s,i1+string8allocsize);
    s^.ref.count:= 1;
    s^.len:= count;
    ref^:= @s^.data;
    (pcard8(pointer(s+1))+count)^:= 0; //terminator
   end;
  end
  else begin
   if i1 = 0 then begin
    freemem(s);
    ref^:= nil;
   end
   else begin
    d:= getmem(i1+string8allocsize);
    i2:= s^.len * 1; //old bytesize
    if i2 <= i1 then begin
     memcpy(@d^.data,@s^.data,i2);
    end
    else begin
     memcpy(@d^.data,@s^.data,i1);
    end;
    (pcard8(pointer(s+1))+count)^:= 0; //terminator
   end;
   dec(s^.ref.count);
   d^.ref.count:= 1;
   d^.len:= count;
   ref^:= @d^.data;
  end;
 end
 else begin
  if count > 0 then begin
   s:= getmem(i1+string8allocsize);
   s^.ref.count:= 1;
   s^.len:= count;
   ref^:= @s^.data;
   (pcard8(pointer(s+1))+count)^:= 0; //terminator
  end;
 end;
end;

procedure __mla__setlengthstring16(const ref: ppointer; const count: int32);
var
 s,d: pstringheaderty;
 i1,i2: int32;
begin
 i1:= count * 2; //bytesize
 s:= ref^;
 if s <> nil then begin
  dec(s);
  if s^.ref.count = 1 then begin
   if i1 = 0 then begin
    freemem(s);
    ref^:= nil;
   end
   else begin
    reallocmem(s,i1+string16allocsize);
    s^.ref.count:= 1;
    s^.len:= count;
    ref^:= @s^.data;
    (pcard16(pointer(s+1))+count)^:= 0; //terminator
   end;
  end
  else begin
   if i1 = 0 then begin
    freemem(s);
    ref^:= nil;
   end
   else begin
    d:= getmem(i1+string16allocsize);
    i2:= s^.len * 2; //old bytesize
    if i2 <= i1 then begin
     memcpy(@d^.data,@s^.data,i2);
    end
    else begin
     memcpy(@d^.data,@s^.data,i1);
    end;
    (pcard16(pointer(s+1))+count)^:= 0; //terminator
   end;
   dec(s^.ref.count);
   d^.ref.count:= 1;
   d^.len:= count;
   ref^:= @d^.data;
  end;
 end
 else begin
  if count > 0 then begin
   s:= getmem(i1+string16allocsize);
   s^.ref.count:= 1;
   s^.len:= count;
   ref^:= @s^.data;
   (pcard16(pointer(s+1))+count)^:= 0; //terminator
  end;
 end;
end;

procedure __mla__setlengthstring32(const ref: ppointer; const count: int32);
var
 s,d: pstringheaderty;
 i1,i2: int32;
begin
 i1:= count * 4; //bytesize
 s:= ref^;
 if s <> nil then begin
  dec(s);
  if s^.ref.count = 1 then begin
   if i1 = 0 then begin
    freemem(s);
    ref^:= nil;
   end
   else begin
    reallocmem(s,i1+string32allocsize);
    s^.ref.count:= 1;
    s^.len:= count;
    ref^:= @s^.data;
    (pcard32(pointer(s+1))+count)^:= 0; //terminator
   end;
  end
  else begin
   if i1 = 0 then begin
    freemem(s);
    ref^:= nil;
   end
   else begin
    d:= getmem(i1+string32allocsize);
    i2:= s^.len * 4; //old bytesize
    if i2 <= i1 then begin
     memcpy(@d^.data,@s^.data,i2);
    end
    else begin
     memcpy(@d^.data,@s^.data,i1);
    end;
    (pcard32(pointer(s+1))+count)^:= 0; //terminator
   end;
   dec(s^.ref.count);
   d^.ref.count:= 1;
   d^.len:= count;
   ref^:= @d^.data;
  end;
 end
 else begin
  if count > 0 then begin
   s:= getmem(i1+string32allocsize);
   s^.ref.count:= 1;
   s^.len:= count;
   ref^:= @s^.data;
   (pcard32(pointer(s+1))+count)^:= 0; //terminator
  end;
 end;
end;


procedure __mla__uniquedynarray(const ref: ppointer; const itemsize: int32);
var
 s,d: pdynarrayheaderty;
 i1: int32;
begin
 s:= ref^;
 if s <> nil then begin
  dec(s);
  if s^.ref.count <> 1 then begin
   i1:= (s^.high+1)*itemsize + dynarrayallocsize;
   d:= getmem(i1);
   memcpy(d,s,i1);
   dec(s^.ref.count);
   d^.ref.count:= 1;
   ref^:= @d^.data;
  end;
 end;
end;

procedure __mla__uniquestring8(const ref: ppointer);
var
 s,d: pstringheaderty;
 i1: int32;
begin
 s:= ref^;
 if s <> nil then begin
  dec(s);
  if s^.ref.count <> 1 then begin
   i1:= (s^.len)*1 + string8allocsize;
   d:= getmem(i1);
   memcpy(d,s,i1);
   if s^.ref.count > 0 then begin
    dec(s^.ref.count);
   end;
   d^.ref.count:= 1;
   ref^:= @d^.data;
  end;
 end;
end;

procedure __mla__uniquestring16(const ref: ppointer);
var
 s,d: pstringheaderty;
 i1: int32;
begin
 s:= ref^;
 if s <> nil then begin
  dec(s);
  if s^.ref.count <> 1 then begin
   i1:= (s^.len)*2 + string16allocsize;
   d:= getmem(i1);
   memcpy(d,s,i1);
   if s^.ref.count > 0 then begin
    dec(s^.ref.count);
   end;
   d^.ref.count:= 1;
   ref^:= @d^.data;
  end;
 end;
end;

procedure __mla__uniquestring32(const ref: ppointer);
var
 s,d: pstringheaderty;
 i1: int32;
begin
 s:= ref^;
 if s <> nil then begin
  dec(s);
  if s^.ref.count <> 1 then begin
   i1:= (s^.len)*4 + string32allocsize;
   d:= getmem(i1);
   memcpy(d,s,i1);
   if s^.ref.count > 0 then begin
    dec(s^.ref.count);
   end;
   d^.ref.count:= 1;
   ref^:= @d^.data;
  end;
 end;
end;

const
 errorcodepoint = $3f; //?

procedure getcodepoint(var ps: pcard8; const pe: pcard8;
                                  out ares: card32);
 function checkok(var acodepoint: card32): boolean; //inline;
 var
  c1: card8;
 begin
  result:= false;
  inc(ps);
  if ps >= pe then begin
   acodepoint:= errorcodepoint;
  end
  else begin
   c1:= ps^ - %10000000;
   if c1 > %00111111 then begin
    acodepoint:= errorcodepoint;
   end
   else begin
    acodepoint:= (acodepoint shl 6) or c1;
    result:= true;
   end;
  end;
 end;

begin
 if ps^ < %10000000 then begin   //1 byte
  ares:= ps^;
 end
 else begin
  if ps^ <= %11100000 then begin //2 bytes
   ares:= ps^ and %00011111;
   if checkok(ares) then begin
    if ares < %1000000 then begin
     ares:= errorcodepoint; //overlong
    end;
   end;
  end
  else begin
   if ps^ < %11110000 then begin //3 bytes
    ares:= ps^ and %00001111;
    if checkok(ares) and checkok(ares) then begin
     if ares < %100000000000 then begin
      ares:= errorcodepoint; //overlong
     end;
    end;
   end
   else begin
    if ps^ < %11111000 then begin //4 bytes
     ares:= ps^ and %00000111;
     if checkok(ares) and checkok(ares) and checkok(ares) then begin
      if ares < %10000000000000000 then begin
       ares:= errorcodepoint; //overlong
      end;
     end;
    end
    else begin
     ares:= errorcodepoint;
    end;
   end;
  end;
 end;
 inc(ps);
 if (ares >= $d800) and (ares <= $dfff) then begin
  ares:= errorcodepoint; //surrogate
 end;
end;

function getcodepoint(var ps: pcard16; const pe: pcard16;
                                  out ares: card32): boolean;
begin
 result:= true;
 ares:= ps^;
 inc(ps);
 if ares and $fc00 = $d800 then begin
  ares:= (ares - $d800) shl 10;
  if ps < pe then begin
   ares:= ares + ps^ - $dc00 + $10000;
   inc(ps);
   if ares < $10000 then begin
    ares:= errorcodepoint; //overlong
   end;
  end
  else begin
   ares:= errorcodepoint; //missing surrogate
  end;
 end;
 if (ares >= $d800) and (ares <= $dfff) then begin
  ares:= errorcodepoint; //surrogate pair
 end;
end;

procedure setutf8(const codepoint: card32; var dest: pcard8);
begin
 if codepoint < $80 then begin
  dest^:= codepoint;
 end
 else begin
  if codepoint < $800 then begin //2 byte
   dest^:= (codepoint shr 6) or %11000000;
   inc(dest);
   dest^:= codepoint and %00111111 or %10000000;
  end
  else begin
   if codepoint < $10000 then begin //3 byte
    dest^:= (codepoint shr 12) or %11100000;
    inc(dest);
    dest^:= (codepoint shr 6) and %00111111 or %10000000;
    inc(dest);
    dest^:= codepoint and %00111111 or %10000000;
   end
   else begin                       //4 byte
    dest^:= (codepoint shr 18) or %11110000;
    inc(dest);
    dest^:= (codepoint shr 12) and %00111111 or %10000000;
    inc(dest);
    dest^:= (codepoint shr 6) and %00111111 or %10000000;
    inc(dest);
    dest^:= codepoint and %00111111 or %10000000;
   end;
  end;
 end;
 inc(dest);
end;
(*
function __mla__string8to16(source: pointer): pointer;
var
 pss,pds: pstringheaderty;
 p1,pe: pcard8;
 p2,p3: pcard16;
 c1: card32;
begin
 pss:= source;
 if pss <> nil then begin
  p1:= pointer(pss);
  dec(pss); //header
  pe:= p1+pss^.len;
  pds:= getmem(string16allocsize+pss^.len*2); //max
  p2:= pointer(pds+1);
  p3:= p2;
  while p1 < pe do begin
   getcodepoint(p1,pe,c1);
   if c1 < $10000 then begin
    p2^:= c1;
   end
   else begin
    c1:= c1 - $10000;
    p2^:= (c1 shr 10) and $3ff or $d800;
    inc(p2);
    p2^:= c1 and $3ff or $dc00;
   end;
   inc(p2);
  end;
  p2^:= 0;
  pds^.ref.count:= temprefcount;
  pds^.len:= p2-p3;
  inc(pds); //data
 end
 else begin
  pds:= nil;
 end;
 result:= pds;
end;
*)
function __mla__string8to16(source: pointer): pointer;
var
 pss,pds: pstringheaderty;
 by1: card8;
 wo1: card16;
 ps,pe: pcard8;
 pd,pd0: pcard16;
begin
 pss:= source;
 if pss <> nil then begin
  ps:= pointer(pss); //data
  dec(pss); //header
  pe:= ps+pss^.len;
  pds:= getmem(string16allocsize+pss^.len*2); //max
  pd:= pointer(pds+1);//data
  pd0:= pd;           //startref
  while ps < pe do begin
   by1:= ps^;
   inc(ps);
   if by1 < $80 then begin //1 byte
    pd^:= by1;
   end
   else begin
    if by1 < $e0 then begin //2 byte
     if (ps < pe) and (ps^ and $c0 = $80) then begin 
      wo1:= (card16(by1 and $1f) shl 6) or (ps^ and $3f);
      pd^:= wo1;
      if pd^ < $80 then begin
       pd^:= errorcodepoint;  //overlong
      end;
      inc(ps);
     end
     else begin
      pd^:= errorcodepoint;
     end;
    end
    else begin
     if (by1 < $f0) then begin //3byte
      if (pe - ps >= 1) and (ps^ and $c0 = $80) and 
                                          ((ps+1)^ and $c0 = $80) then begin 
       pd^:= (card16(by1) shl 12) or 
             (card16(ps^ and $3f) shl 6) or ((ps+1)^ and $3f);
       if pd^ < $0800 then begin
        pd^:= errorcodepoint; //overlong
       end;
       inc(ps,2);
      end
      else begin
       pd^:= errorcodepoint;
      end;
     end
     else begin
      if (by1 < $f8) then begin //4byte
       if (pe - ps >= 2) and (ps^ and $c0 = $80) and ((ps+1)^ and $c0 = $80) and 
                               ((ps+2)^ and $c0 = $80) then begin
        if ((by1 <= $e0) and (ps^ < $90)) then begin //overlong
         pd^:= errorcodepoint; //overlong;
        end
        else begin                                     
         pd^:= ((card16(by1 and $07) shl 8) or 
                (card16(ps^ and $3f) shl 2) or
                (card16((ps+1)^ and $30) shr 4)) + 
                          (card16($d800) - card16($10000 shr 10));
         inc(pd);
         pd^:= (card16((ps+1)^ and $0f) shl 6) or 
                                          ((ps+2)^ and $3f) or word($dc00);
        end;
        inc(ps,3);
       end
       else begin
        pd^:= errorcodepoint;
       end;
      end
      else begin
       pd^:= errorcodepoint;
      end;
     end;
    end;
   end;
   inc(pd);
  end;
  pd^:= 0;
  pds^.ref.count:= temprefcount;
  pds^.len:= pd-pd0;
  inc(pds); //data
 end
 else begin
  pds:= nil;
 end;
 result:= pds;
end;

//todo: maybe use string result (faf_varsubres)

function __mla__string8to32(source: pointer): pointer;
var
 pss,pds: pstringheaderty;
 p1,pe: pcard8;
 p2,p3: pcard32;
begin
 pss:= source;
 if pss <> nil then begin
  p1:= pointer(pss);
  dec(pss); //header
  pe:= p1+pss^.len;
  pds:= getmem(string32allocsize+pss^.len*4); //max
  p2:= pointer(pds+1);
  p3:= p2;
  while p1 < pe do begin
   getcodepoint(p1,pe,p2^);
   inc(p2);
  end;
  p2^:= 0;
  pds^.ref.count:= temprefcount;
  pds^.len:= p2-p3;
  inc(pds); //data
 end
 else begin
  pds:= nil;
 end;
 result:= pds;
end;

function __mla__string16to8(source: pointer): pointer;
var
 pss,pds: pstringheaderty;
 p1,pe: pcard16;
 p2,p3: pcard8;
 c1: card32;
begin
 pss:= source;
 if pss <> nil then begin
  p1:= pointer(pss);
  dec(pss); //header
  pe:= p1+pss^.len;
  pds:= getmem(string8allocsize+pss^.len*3); //max
                                            //todo: use less memory
  p2:= pointer(pds+1);
  p3:= p2;
  while p1 < pe do begin
   getcodepoint(p1,pe,c1);
   setutf8(c1,p2);
  end;
  p2^:= 0;
  pds^.ref.count:= temprefcount;
  pds^.len:= p2-p3;
  inc(pds); //data
 end
 else begin
  pds:= nil;
 end;
 result:= pds;
end;

function __mla__string16to32(source: pointer): pointer;
var
 pss,pds: pstringheaderty;
 p1,pe: pcard16;
 p2,p3: pcard32;
begin
 pss:= source;
 if pss <> nil then begin
  p1:= pointer(pss);
  dec(pss); //header
  pe:= p1+pss^.len;
  pds:= getmem(string32allocsize+pss^.len*4); //max
  p2:= pointer(pds+1);
  p3:= p2;
  while p1 < pe do begin
   getcodepoint(p1,pe,p2^);
   inc(p2);
  end;
  p2^:= 0;
  pds^.ref.count:= temprefcount;
  pds^.len:= p2-p3;
  inc(pds); //data
 end
 else begin
  pds:= nil;
 end;
 result:= pds;
end;

function __mla__string32to8(source: pointer): pointer;
var
 pss,pds: pstringheaderty;
 p1,pe: pcard32;
 p2,p3: pcard8;
 c1: card32;
begin
 pss:= source;
 if pss <> nil then begin
  p1:= pointer(pss);
  dec(pss); //header
  pe:= p1+pss^.len;
  pds:= getmem(string8allocsize+pss^.len*4); //max
                                            //todo: use less memory
  p2:= pointer(pds+1);
  p3:= p2;
  while p1 < pe do begin
   setutf8(p1^,p2);
   inc(p1);
  end;
  p2^:= 0;
  pds^.ref.count:= temprefcount;
  pds^.len:= p2-p3;
  inc(pds); //data
 end
 else begin
  pds:= nil;
 end;
 result:= pds;
end;

function __mla__string32to16(source: pointer): pointer;
var
 pss,pds: pstringheaderty;
 p1,pe: pcard32;
 p2,p3: pcard16;
 c1: card32;
begin
 pss:= source;
 if pss <> nil then begin
  p1:= pointer(pss);
  dec(pss); //header
  pe:= p1+pss^.len;
  pds:= getmem(string16allocsize+pss^.len*2*2); //max
                                            //todo: use less memory
  p2:= pointer(pds+1);
  p3:= p2;
  while p1 < pe do begin
   c1:= p1^;
   if c1 < $10000 then begin
    p2^:= c1;
   end
   else begin
    c1:= c1 - $10000;
    p2^:= (c1 shr 10) and $3ff or $d800;
    inc(p2);
    p2^:= c1 and $3ff or $dc00;
   end;
   inc(p2);
   inc(p1);
  end;
  p2^:= 0;
  pds^.ref.count:= temprefcount;
  pds^.len:= p2-p3;
  inc(pds); //data
 end
 else begin
  pds:= nil;
 end;
 result:= pds;
end;

function __mla__concatstring8(count: int32;
                              strings: ppointer): pointer;
var
 p1,pe: ppstringheaderty;
 ps,pd: pstringheaderty;
 i1: int32;
begin
 p1:= strings;
 pe:= p1+count;
 i1:= 0;
 while p1 < pe do begin
  ps:= p1^;
  if ps <> nil then begin
   i1:= i1 + (ps-1)^.len;
  end;
  inc(p1);
 end;
 if i1 > 0 then begin
  pd:= getmem(string8allocsize+i1*1);
  pd^.ref.count:= temprefcount;
  pd^.len:= i1;
  inc(pd);
  result:= pd;
  (pcard8(pointer(pd))+i1)^:= 0; //terminator
  p1:= strings;
  while p1 < pe do begin
   ps:= p1^;
   if ps <> nil then begin
    i1:= (ps-1)^.len*1;
    memcpy(pd,ps,i1*1);
    inc(pointer(pd),i1);
   end;
   inc(p1);
  end;
 end
 else begin
  result:= nil;
 end;
end;

function __mla__concatstring16(count: int32;
                                   strings: ppointer): pointer;
var
 p1,pe: ppstringheaderty;
 ps,pd: pstringheaderty;
 i1: int32;
begin
 p1:= strings;
 pe:= p1+count;
 i1:= 0;
 while p1 < pe do begin
  ps:= p1^;
  if ps <> nil then begin
   i1:= i1 + (ps-1)^.len;
  end;
  inc(p1);
 end;
 if i1 > 0 then begin
  pd:= getmem(string8allocsize+i1*1);
  pd^.ref.count:= temprefcount;
  pd^.len:= i1;
  inc(pd);
  result:= pd;
  (pcard16(pointer(pd))+i1)^:= 0; //terminator
  p1:= strings;
  while p1 < pe do begin
   ps:= p1^;
   if ps <> nil then begin
    i1:= (ps-1)^.len*2;
    memcpy(pd,ps,i1);
    inc(pointer(pd),i1);
   end;
   inc(p1);
  end;
 end
 else begin
  result:= nil;
 end;
end;

function __mla__concatstring32(count: int32;
                                   strings: ppointer): pointer;
var
 p1,pe: ppstringheaderty;
 ps,pd: pstringheaderty;
 i1: int32;
begin
 p1:= strings;
 pe:= p1+count;
 i1:= 0;
 while p1 < pe do begin
  ps:= p1^;
  if ps <> nil then begin
   i1:= i1 + (ps-1)^.len;
  end;
  inc(p1);
 end;
 if i1 > 0 then begin
  pd:= getmem(string8allocsize+i1*1);
  pd^.ref.count:= temprefcount;
  pd^.len:= i1;
  inc(pd);
  result:= pd;
  (pcard16(pointer(pd))+i1)^:= 0; //terminator
  p1:= strings;
  while p1 < pe do begin
   ps:= p1^;
   if ps <> nil then begin
    i1:= (ps-1)^.len*4;
    memcpy(pd,ps,i1);
    inc(pointer(pd),i1);
   end;
   inc(p1);
  end;
 end
 else begin
  result:= nil;
 end;
end;

function compstring8(a,b:pointer): stringsizety; //a and b <> nil
var
 poa,poe,pob: pcard8;
 la,lb: stringsizety;
 i1: int8;
begin
 la:= (pstringheaderty(a)-1)^.len;
 lb:= (pstringheaderty(b)-1)^.len;
 poa:= a;
 pob:= b;
 if la < lb then begin
  poe:= poa + la;
 end
 else begin
  poe:= poa + lb;
 end;
 while true do begin
  i1:= poa^ - pob^;
  if i1 <> 0 then begin
   result:= i1;
   exit;
  end;
  inc(poa);
  if poa >= poe then begin
   break;
  end;
  inc(pob);
 end;
 result:= la - lb; //cut text equal, compare length
end;

function compstring16(a,b:pointer): stringsizety; //a and b <> nil
var
 poa,poe,pob: pcard16;
 la,lb: stringsizety;
 i1: int16;
begin
 la:= (pstringheaderty(a)-1)^.len;
 lb:= (pstringheaderty(b)-1)^.len;
 poa:= a;
 pob:= b;
 if la < lb then begin
  poe:= poa + la;
 end
 else begin
  poe:= poa + lb;
 end;
 while true do begin
  i1:= poa^ - pob^;
  if i1 <> 0 then begin
   result:= i1;
   exit;
  end;
  inc(poa);
  if poa >= poe then begin
   break;
  end;
  inc(pob);
 end;
 result:= la - lb; //cut text equal, compare length
end;

function compstring32(a,b:pointer): stringsizety; //a and b <> nil
var
 poa,poe,pob: pcard32;
 la,lb: stringsizety;
 i1: int32;
begin
 la:= (pstringheaderty(a)-1)^.len;
 lb:= (pstringheaderty(b)-1)^.len;
 poa:= a;
 pob:= b;
 if la < lb then begin
  poe:= poa + la;
 end
 else begin
  poe:= poa + lb;
 end;
 while true do begin
  i1:= poa^ - pob^;
  if i1 <> 0 then begin
   result:= i1;
   exit;
  end;
  inc(poa);
  if poa >= poe then begin
   break;
  end;
  inc(pob);
 end;
 result:= la - lb; //cut text equal, compare length
end;

function __mla__compstring8eq(a,b: pointer): bool1;
begin
 result:= a = b;
 if not result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring8(a,b) = 0;
  end
  else begin
   result:= false;
  end;
 end;
end;

function __mla__compstring8ne(a,b: pointer): bool1;
begin
 result:= a <> b;
 if result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring8(a,b) <> 0;
  end
  else begin
   result:= true;
  end;
 end;
end;

function __mla__compstring8gt(a,b: pointer): bool1;
begin
 result:= a <> b;
 if result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring8(a,b) > 0;
  end
  else begin
   result:= b = nil;
  end;
 end;
end;

function __mla__compstring8lt(a,b: pointer): bool1;
begin
 result:= a <> b;
 if result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring8(a,b) < 0;
  end
  else begin
   result:= a = nil;
  end;
 end;
end;

function __mla__compstring8ge(a,b: pointer): bool1;
begin
 result:= a = b;
 if not result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring8(a,b) >= 0;
  end
  else begin
   result:= b = nil;
  end;
 end;
end;

function __mla__compstring8le(a,b: pointer): bool1;
begin
 result:= a = b;
 if not result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring8(a,b) <= 0;
  end
  else begin
   result:= a = nil;
  end;
 end;
end;

function __mla__compstring16eq(a,b: pointer): bool1;
begin
 result:= a = b;
 if not result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring16(a,b) = 0;
  end
  else begin
   result:= false;
  end;
 end;
end;

function __mla__compstring16ne(a,b: pointer): bool1;
begin
 result:= a <> b;
 if result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring16(a,b) <> 0;
  end
  else begin
   result:= true;
  end;
 end;
end;

function __mla__compstring16gt(a,b: pointer): bool1;
begin
 result:= a <> b;
 if result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring16(a,b) > 0;
  end
  else begin
   result:= b = nil;
  end;
 end;
end;

function __mla__compstring16lt(a,b: pointer): bool1;
begin
 result:= a <> b;
 if result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring16(a,b) < 0;
  end
  else begin
   result:= a = nil;
  end;
 end;
end;

function __mla__compstring16ge(a,b: pointer): bool1;
begin
 result:= a = b;
 if not result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring16(a,b) >= 0;
  end
  else begin
   result:= b = nil;
  end;
 end;
end;

function __mla__compstring16le(a,b: pointer): bool1;
begin
 result:= a = b;
 if not result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring16(a,b) <= 0;
  end
  else begin
   result:= a = nil;
  end;
 end;
end;

function __mla__compstring32eq(a,b: pointer): bool1;
begin
 result:= a = b;
 if not result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring32(a,b) = 0;
  end
  else begin
   result:= false;
  end;
 end;
end;

function __mla__compstring32ne(a,b: pointer): bool1;
begin
 result:= a <> b;
 if result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring32(a,b) <> 0;
  end
  else begin
   result:= true;
  end;
 end;
end;

function __mla__compstring32gt(a,b: pointer): bool1;
begin
 result:= a <> b;
 if result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring32(a,b) > 0;
  end
  else begin
   result:= b = nil;
  end;
 end;
end;

function __mla__compstring32lt(a,b: pointer): bool1;
begin
 result:= a <> b;
 if result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring32(a,b) < 0;
  end
  else begin
   result:= a = nil;
  end;
 end;
end;

function __mla__compstring32ge(a,b: pointer): bool1;
begin
 result:= a = b;
 if not result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring32(a,b) >= 0;
  end
  else begin
   result:= b = nil;
  end;
 end;
end;

function __mla__compstring32le(a,b: pointer): bool1;
begin
 result:= a = b;
 if not result then begin
  if (a <> nil) and (b <> nil) then begin
   result:= compstring32(a,b) <= 0;
  end
  else begin
   result:= a = nil;
  end;
 end;
end;

function __mla__chartostring8(achar: card8): pointer;
var
 po1: pstringheaderty;
begin
 po1:= getmem(1*1+string8allocsize);
 po1^.len:= 1;
 po1^.ref.count:= 1;
 result:= po1+1; //data
 pcard8(result)^:= achar;
 (pcard8(result)+1)^:= 0; //terminator
end;

function __mla__chartostring16(achar: card16): pointer;
var
 po1: pstringheaderty;
begin
 po1:= getmem(1*2+string16allocsize);
 po1^.len:= 1;
 po1^.ref.count:= 1;
 result:= po1+1; //data
 pcard16(result)^:= achar;
 (pcard16(result)+1)^:= 0; //terminator
end;

function __mla__chartostring32(achar: card32): pointer;
var
 po1: pstringheaderty;
begin
 po1:= getmem(1*4+string32allocsize);
 po1^.len:= 1;
 po1^.ref.count:= 1;
 result:= po1+1; //data
 pcard32(result)^:= achar;
 (pcard32(result)+1)^:= 0; //terminator
end;

procedure __mla__arraytoopenar(ahigh: int32; adata: pointer;
                                      out result: openarrayty);
begin
 result.high:= ahigh;
 result.data:= adata;
end;

procedure __mla__dynarraytoopenar(ref: pointer; out result: openarrayty);
begin
 if ref = nil then begin
  result.high:= -1;
 end
 else begin
  result.high:= (pdynarrayheaderty(ref)-1)^.high;
 end;
 result.data:= ref;
end;

function __mla__lengthdynarray(ref: pointer): int32;
begin
 if ref <> nil then begin
  result:= (pdynarrayheaderty(ref)-1)^.high + 1;
 end
 else begin
  result:= 0;
 end;
end;

function __mla__lengthopenarray(ref: popenarrayty): int32;
begin
 result:= ref^.high+1;
end;

function __mla__lengthstring(ref: pointer): int32;
begin
 if ref <> nil then begin
  result:= (pstringheaderty(ref)-1)^.len;
 end
 else begin
  result:= 0;
 end;
end;

function __mla__highdynarray(ref: pointer): int32;
begin
 if ref <> nil then begin
  result:= (pdynarrayheaderty(ref)-1)^.high;
 end
 else begin
  result:= -1;
 end;
end;

function __mla__highopenarray(ref: popenarrayty): int32;
begin
 result:= ref^.high;
end;


function __mla__highstring(ref: pointer): int32;
begin
 if ref <> nil then begin
  result:= (pstringheaderty(ref)-1)^.len;
 end
 else begin
  result:= 0;
 end;
end;

procedure __mla__initobject(const instance: pointer;
                                           const classinfo: classdefinfoty);
var
 ps,pd,pe: ppointer;
 po1: pclassdefinfoty;
begin
 po1:= @classinfo;
// ppointer(instance+virttaboffset)^:= po1;//@classinfo;
 ppointer(instance+classinfo.header.virttaboffset)^:= po1;//@classinfo;
{$ifdef mse_debugclass}
 writeln('***initobject ',result);
{$endif}
 repeat
  pd:= instance + po1^.header.allocs.instanceinterfacestart;
                                            //copy interface table
  pe:= instance + po1^.header.allocs.size;
  ps:= pointer(po1) + po1^.header.allocs.classdefinterfacestart;
 {$ifdef mse_debugclass}
  writeln(' *classdef:',po1);
  writeln('  parentclass:',po1^.header.parentclass);
  writeln('  interfaceparent:',po1^.header.interfaceparent);
  writeln('  allocs.size:',po1^.header.allocs.size);
  writeln('  interfacestart:',po1^.header.allocs.instanceinterfacestart);
  writeln('  classdefinterfacestart:',po1^.header.allocs.classdefinterfacestart);
 {$endif}
  while pd < pe do begin
   pd^:= ps^;
  {$ifdef mse_debugclass}
   writeln('  intf:',int32(pointer(pd)-instance),' ',pd,'^:',pd^,
                 ' instanceoffset:',pintfdefinfoty(pd^)^.header.instanceoffset);
  {$endif}
   inc(pd);
   inc(ps);
  end;
  po1:= po1^.header.interfaceparent;
 until po1 = nil;
end;
{
procedure __mla__calliniobject(const instance: pointer;
                                          const classinfo: classdefinfoty);
begin
 classinfo.header.procs[cdp_ini](instance);
end;
}
function __mla__getclassdef(const instance: pointer;
                          const virttaboffset: int32): pointer;
begin
 result:= instance;
 if instance <> nil then begin
  result:= ppointer(instance+virttaboffset)^;
 end;
end;

function __mla__getallocsize(const classdef: pclassdefinfoty): int32;
begin
 result:= classdef^.header.allocs.size;
end;

function __mla__classis(const a,b: pclassdefinfoty): bool1;
var
 p1: pclassdefinfoty;
begin
 result:= false;
 if (a <> nil) and (b <> nil) then begin
  p1:= a;
  repeat
   if p1 = b then begin
    result:= true;
    break;
   end;
   p1:= p1^.header.parentclass;
  until p1 = nil;
 end;
end;

function __mla__checkclasstype(var instance: pointer; 
                              const classtype: pclassdefinfoty): bool1;
begin
 if (instance <> nil) and 
         __mla__classis(ppointer(instance)^,classtype) then begin
  result:= true;
 end
 else begin
  result:= false;
  instance:= nil;  
 end;
end;

function getenumname(const enumvalue: int32; const rtti: penumrttity): string8;
var
 p1,pe: ^enumitemrttity;
begin
 result:= '';
 p1:= pointer(@rtti^.items);
 if erf_contiguous in rtti^.flags then begin
  if (enumvalue >= 0) and (enumvalue < rtti^.itemcount) then begin
   decref(result);
   pointer(result):= pointer((p1 + enumvalue)^.name); //const string, no incref
  end;
 end
 else begin
  pe:= p1+rtti^.itemcount;
  while p1 < pe do begin
   if p1^.value = enumvalue then begin
    decref(result);
    pointer(result):= pointer(p1^.name);     //const string, no incref
    break;
   end;
   inc(p1);
  end;
 end;
end;

procedure __mla__writeenum(const avalue: int32;
                              const artti: penumrttity);
begin
 write(getenumname(avalue,artti));
end;

(*
//todo: use simplified version if there are no interfaces
function __mla__initclass(const classinfo: classdefinfoty): pointer;
var
 ps,pd,pe: ppointer;
 po1: pclassdefinfoty;
begin
 getzeromem(result,classinfo.header.allocs.size);
 po1:= @classinfo;
 ppointer(result)^:= @classinfo;
{$ifdef mse_debugclass}
 writeln('***initclass ',result);
{$endif}
 repeat
  pd:= result + po1^.header.allocs.instanceinterfacestart;
                                            //copy interface table
  pe:= result + po1^.header.allocs.size;
  ps:= pointer(po1) + po1^.header.allocs.classdefinterfacestart;
 {$ifdef mse_debugclass}
  writeln(' *classdef:',po1);
  writeln('  parentclass:',po1^.header.parentclass);
  writeln('  interfaceparent:',po1^.header.interfaceparent);
  writeln('  allocs.size:',po1^.header.allocs.size);
  writeln('  interfacestart:',po1^.header.allocs.instanceinterfacestart);
  writeln('  classdefinterfacestart:',po1^.header.allocs.classdefinterfacestart);
 {$endif}
  while pd < pe do begin
   pd^:= ps^;
  {$ifdef mse_debugclass}
   writeln('  intf:',int32(pointer(pd)-result),' ',pd,'^:',pd^,
                 ' instanceoffset:',pintfdefinfoty(pd^)^.header.instanceoffset);
  {$endif}
   inc(pd);
   inc(ps);
  end;
  po1:= po1^.header.interfaceparent;
 until po1 = nil;
end;
*)

procedure finivirtclass(const instance: pointer);
var
 p1: pclassdefinfoty;
begin
 p1:= ppointer(instance)^;
 if p1^.header.procs[cdp_destruct] <> nil then begin
  p1^.header.procs[cdp_destruct](instance);
 end
 else begin
  freemem(instance);
 end;
end;

procedure exceptioncleanup(reason: _Unwind_Reason_Code;
                                                      exc: p_Unwind_Exception);
begin
 freemem(exc);
end;

procedure __mla__raise(const data: pointer);
var
 po1: pexceptinfoty;
begin  //todo: handle out of memory situation
 po1:= getmem(sizeof(exceptinfoty));
 with po1^.header do begin
  exception_class:= mlaexceptionid;
  exception_cleanup:= @exceptioncleanup;
 end;
 po1^.data:= data;
 _Unwind_RaiseException(@po1^.header);
 freemem(po1);
 finivirtclass(data);
 exitcode:= exco_unhandledexception; //no handler found
 halt();
end;

procedure __mla__finiexception(const data: pointer);
begin
 with pexceptinfoty(data)^ do begin
  if data <> nil then begin
   finivirtclass(data);
  end;
 end;
 freemem(data);
end;

function readusleb128(var adata: pointer): ptrint;
var
 po1: pcard8;
 shift,i1: int32;
begin
 po1:= adata;
 result:= po1^ and $7f;
 shift:= 7;
 while po1^ and $80 <> 0 do begin       //todo: overflow check
  inc(po1);
  result:= result or ptrint(po1^ and $7f) shl shift;
  shift:= shift + 7;
 end;
 adata:= po1+1;
end;

function readssleb128(var adata: pointer): ptrint;
var
 po1: pcard8;
 shift,i1: int32;
begin
 po1:= adata;
 result:= po1^ and $7f;
 shift:= 7;
 while po1^ and $80 <> 0 do begin       //todo: overflow check
  inc(po1);
  result:= result or ptrint(po1^ and $7f) shl shift;
  shift:= shift + 7;
 end;
 if po1^ and $40 <> 0 then begin   //sign
  result:= result or ptrint(-1) shl shift; //negative
 end;
 adata:= po1+1;
end;

procedure fatalerror();
begin
 writeln('Fatal error');
 halt();
end;

const
{$ifdef target_x86_64}
 exceptionregno = 0;
 selectorregno = 1;
{$else}
 exceptionregno = 0;
 selectorregno = 2;
{$endif}

function installfinallycontext(const actions: _Unwind_Action;
             const exceptiondata: p_Unwind_Exception;
             const context: p_Unwind_Context;
             const landingpad: pointer): _Unwind_Reason_Code;
begin
 if actions and _UA_SEARCH_PHASE <> 0 then begin
  result:= _URC_HANDLER_FOUND;
 end
 else begin
  if actions and _UA_HANDLER_FRAME <> 0 then begin
   _Unwind_SetGR(context,exceptionregno,ptrint(exceptiondata));
   _Unwind_SetGR(context,selectorregno,0);
   _Unwind_SetIP(context,landingpad);
   result:= _URC_INSTALL_CONTEXT;
  end
  else begin
   result:= _URC_CONTINUE_UNWIND;
  end;
 end;
end;

procedure __mla__int32tovarrecty(const value: int32; const res: pvarrecty);
begin
 res^.vtype:= vt_int32;
 res^.vint32:= value;
end;

end.
