{ MSEgui Copyright (c) 2014-2015 by Martin Schreiber

    See the file COPYING.MSE, included in this distribution,
    for details about the copyright.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
}
unit __mla__compilerunit;
interface 
uses
 __mla__internaltypes;

procedure __mla__decrefsize(ref: prefsizeinfoty);
procedure __mla__finirefsize(const ref: pprefsizeinfoty);
function __mla__initclass(const classinfo: classdefinfoty): pointer;
procedure __mla__raise(const data: pointer);

function _Unwind_RaiseException(
           exception_object: p_Unwind_Exception): _Unwind_Reason_Code; external;

implementation

procedure __mla__decrefsize(ref: prefsizeinfoty);
begin
 if ref <> nil then begin
  dec(ref);
  if ref^.ref.count > 0 then begin
   dec(ref^.ref.count);
   if ref^.ref.count = 0 then begin
    freemem(ref);
   end;
  end;
 end;
end;

procedure __mla__finirefsize(const ref: pprefsizeinfoty);
var
 d: prefsizeinfoty;
begin
 d:= ref^;
 if d <> nil then begin
  dec(d);
  if d^.ref.count > 0 then begin
   dec(d^.ref.count);
   if d^.ref.count = 0 then begin
    freemem(d);
   end;
  end;
  ref^:= nil;
 end;
end;

//todo: use simplified version if there are no interfaces
function __mla__initclass(const classinfo: classdefinfoty): pointer;
var
 ps,pd,pe: ppointer;
 po1: pclassdefinfoty;
begin
 getzeromem(result,classinfo.header.allocs.size);
 po1:= @classinfo;
 ppointer(result)^:= @classinfo;
//writeln('******* ',result);
 repeat
  pd:= result + po1^.header.allocs.instanceinterfacestart;
                                            //copy interface table
  pe:= result + po1^.header.allocs.size;
  ps:= pointer(po1) + po1^.header.allocs.classdefinterfacestart;
{
writeln('* ',po1,' ',po1^.header.parentclass,' ',
             po1^.header.interfaceparent,' ',
             po1^.header.allocs.size,' ',
             po1^.header.allocs.instanceinterfacestart,' ',
             po1^.header.allocs.classdefinterfacestart);
}
  while pd < pe do begin
   pd^:= ps^;
//writeln(int32(pointer(pd)-result),' ',pd,':',pd^);
   inc(pd);
   inc(ps);
  end;
  po1:= po1^.header.interfaceparent;
 until po1 = nil;
end;

procedure __mla__raise(const data: pointer);
var
 po1: pexceptinfoty;
begin
 getmem(po1,sizeof(exceptinfoty);
// with po1^.header do begin
// end;
end;

end.
