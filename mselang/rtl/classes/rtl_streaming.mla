//rtl_streaming
{ MSEgui Copyright (c) 2018 by Martin Schreiber

    See the file COPYING.MSE, included in this distribution,
    for details about the copyright.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
}

unit rtl_streaming;
interface
uses
 rtl_fpccompatibility,__mla__internaltypes,rtl_streams,rtl_sysexceptions;
//{$internaldebug on}
type
 tpersistent = class;

 efilererror = class(exception) end;
 ereadererror = class(efilererror) end;
 ewritererror = class(ereadererror) end;

 valuety = (va_none,va_int1,va_int8,va_int16,va_int32,va_int64);

 tfiler = class(tobject)
  class method iswriter(): boolean [virtual];
 end;
 
 treader = class(tfiler)
 end;
 
 twriter = class(tfiler)
  constructor create(const astream: tstream);
  class method iswriter(): boolean [override];

  method writevalue(const avalue: valuety);
  method writestr(const avalue: string8); //legth truncated to 255 chars
  method writeinteger(const avalue: int32);
  method writeinteger(const avalue: int64);

  method writeproperties(const instance: tpersistent);
  method writeproperty(const instance: tpersistent;
                                     const propinfo: ppropertyrttity);

  protected
   fstream: tstream;
 end;
 
 tpersistent = class(tobject)
  method assign(source: tpersistent) [virtual];
  method getnamepath(): string8 [virtual];

  protected
   method assignerror(const source: tpersistent);
   method assignto(dest: tpersistent) [virtual];
   method defineproperties(filer: tfiler) [virtual];
   method getowner(): tpersistent [virtual];
 end;
 
implementation
uses
 rtl_rtlconsts,rtl_classutils,rtl_sysexceptions,rtl_rttiutils,rtl_format;
 
procedure writererror(const amessage: string8);
begin
 raise ewritererror.create(amessage);
end;

{ tpersistent }

method tpersistent.assignerror(const source: tpersistent);
begin
 raise econverterror.createfmt(sassignerror,[getclassname(source),classname]);
end;

method tpersistent.assignto(dest: tpersistent);
begin
end;

method tpersistent.defineproperties(filer: tfiler);
begin
end;

method tpersistent.getowner(): tpersistent;
begin
end;

method tpersistent.assign(source: tpersistent);
begin
end;

method tpersistent.getnamepath(): string8;
begin
end;

{ tfiler }

class method tfiler.iswriter(): boolean;
begin
 result:= false;
end;

{ twriter }

constructor twriter.create(const astream: tstream);
begin
 fstream:= astream;
end;

class method twriter.iswriter(): boolean;
begin
 result:= true;
end;

method twriter.writevalue(const avalue: valuety);
var
 c1: card8;
begin
 c1:= card8(card32(avalue));
 fstream.write(c1,1);
end;

method twriter.writestr(const avalue: string8);
var
 i1: int32;
 ca1: card8;
begin
 i1:= length(avalue);
 if i1 > $ff then
  i1:= $ff;
 end;
 ca1:= i1;
 fstream.write(ca1,1);
 if avalue <> '' then
  fstream.write(pointer(avalue)^,i1);
 end;
end;

method twriter.writeinteger(const avalue: int32);
var
 i8: int8;
 i16: int16;
begin
 if (avalue >= -$80) and (avalue < $80) then
  writevalue(va_int8);
  i8:= avalue;
  fstream.write(i8,1);
 else
  if (avalue >= -$8000) and (avalue < $8000) then
   writevalue(va_int16);
   i16:= avalue;
   write(i16,2);
  else
    writevalue(va_int32);
    write(avalue,4);
  end;
 end;  
end;

method twriter.writeinteger(const avalue: int64);
begin
 if (avalue >= -$8000) and (avalue < $8000) then
  writeinteger(int32(avalue));
 else
  writevalue(va_int64);
  write(avalue,8);
 end;
end;

method twriter.writeproperty(const instance: tpersistent;
               const propinfo: ppropertyrttity);
begin
 if propinfo^.flags * [prf_readfield,prf_readproc] = [] then
  exit; //can not get data for writing
 end;
 writestr(string8(propinfo^.name));
 case propinfo^.proptype^.kind of
  rtk_integer:
   writeinteger(getordprop(instance,propinfo));
  rtk_string:
  else:
   writererror(format(scannotwritepropertykind,[string8(propinfo^.name),
               getenumname(typeinfo(propinfo^.proptype^.kind),
                                          ord(propinfo^.proptype^.kind))]));
 end;
end;

method twriter.writeproperties(const instance: tpersistent);
var
 ar1: propertyrttiarty;
 p1,pe: pppropertyrttity;
begin
 ar1:= getproperties(instance);
 p1:= pointer(ar1);
 pe:= p1 + length(ar1);
 while p1 < pe do
  writeproperty(instance,p1^);
  inc(p1);
 end;
end;

end.
