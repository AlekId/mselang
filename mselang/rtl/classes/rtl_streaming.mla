//rtl_streaming
{ MSEgui Copyright (c) 2018 by Martin Schreiber

    See the file COPYING.MSE, included in this distribution,
    for details about the copyright.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
}

unit rtl_streaming;
interface
uses
 rtl_fpccompatibility,__mla__internaltypes,rtl_streams,rtl_sysexceptions;
//{$internaldebug on}
type
 tpersistent = class;

 efilererror = class(exception) end;
 ereadererror = class(efilererror) end;
 ewritererror = class(ereadererror) end;

 valuety = (va_none,va_int1,va_int8,va_int16,va_int32,va_int64,
            va_strl1,va_strl2,va_strl4 //size of length value
           );

 tfiler = class(tobject)
  class method iswriter(): boolean [virtual];
 end;
 
 treader = class(tfiler)
 end;
 
 twriter = class(tfiler)
  constructor create(const astream: tstream);
  class method iswriter(): boolean [override];

  method writevalue(const avalue: valuety);
  method writestr(const avalue: string8); //length truncated to 255 chars

  method writeinteger(const avalue: int32);
  method writeinteger(const avalue: int64);
  method writebytestring(const avalue: bytestring);
  method writestring8(const avalue: string8);
  method writestring16(const avalue: string16);
  method writestring32(const avalue: string32);

  method writeproperties(const instance: tpersistent);
  method writeproperty(const instance: tpersistent;
                                     const propinfo: ppropertyrttity);

  protected
   fstream: tstream;
 end;
 
 tpersistent = class(tobject)
  method assign(source: tpersistent) [virtual];
  method getnamepath(): string8 [virtual];

  protected
   method assignerror(const source: tpersistent);
   method assignto(dest: tpersistent) [virtual];
   method defineproperties(filer: tfiler) [virtual];
   method getowner(): tpersistent [virtual];
 end;
 
implementation
uses
 rtl_rtlconsts,rtl_classutils,rtl_sysexceptions,rtl_rttiutils,rtl_format;
 
procedure writererror(const amessage: string8);
begin
 raise ewritererror.create(amessage);
end;

procedure writererror(const amessage: string8; const avalues: array of const);
begin
 raise ewritererror.create(format(amessage,avalues));
end;

{ tpersistent }

method tpersistent.assignerror(const source: tpersistent);
begin
 raise econverterror.createfmt(sassignerror,[getclassname(source),classname]);
end;

method tpersistent.assignto(dest: tpersistent);
begin
end;

method tpersistent.defineproperties(filer: tfiler);
begin
end;

method tpersistent.getowner(): tpersistent;
begin
end;

method tpersistent.assign(source: tpersistent);
begin
end;

method tpersistent.getnamepath(): string8;
begin
end;

{ tfiler }

class method tfiler.iswriter(): boolean;
begin
 result:= false;
end;

{ twriter }

constructor twriter.create(const astream: tstream);
begin
 fstream:= astream;
end;

class method twriter.iswriter(): boolean;
begin
 result:= true;
end;

method twriter.writevalue(const avalue: valuety);
var
 c1: card8;
begin
 c1:= card8(card32(avalue));
 fstream.write(c1,1);
end;

method twriter.writestr(const avalue: string8);
var
 i1: int32;
 ca1: card8;
begin
 i1:= length(avalue);
 if i1 > $ff then
  i1:= $ff;
 end;
 ca1:= i1;
 fstream.write(ca1,1);
 if avalue <> '' then
  fstream.write(pointer(avalue)^,i1);
 end;
end;

method twriter.writeinteger(const avalue: int32);
var
 i8: int8;
 i16: int16;
begin
 if (avalue >= -$80) and (avalue < $80) then
  writevalue(va_int8);
  i8:= avalue;
  fstream.write(i8,1);
 else
  if (avalue >= -$8000) and (avalue < $8000) then
   writevalue(va_int16);
   i16:= avalue;
   write(i16,2);
  else
    writevalue(va_int32);
    write(avalue,4);
  end;
 end;  
end;

method twriter.writeinteger(const avalue: int64);
begin
 if (avalue >= -$8000) and (avalue < $8000) then
  writeinteger(int32(avalue));
 else
  writevalue(va_int64);
  write(avalue,8);
 end;
end;

method twriter.writebytestring(const avalue: bytestring);
var
 i1: int32;
 c1: card8;
 c2: card16;
 
begin
 i1:= length(avalue);
 if i1 < $100 then
  writevalue(va_strl1);
  c1:= i1;
  write(c1,sizeof(c1));
 else
  if i1 < $10000 then
   writevalue(va_strl2);
   c2:= i1;
   write(c2,sizeof(c2));
  else
   writevalue(va_strl4);
   write(i1,sizeof(i1));
  end;
 end;
 write(pointer(avalue)^,i1);
end;

method twriter.writestring8(const avalue: string8);
begin
 writebytestring(bytestring(pointer(avalue)));
end;

method twriter.writestring16(const avalue: string16);
begin
 writestring8(string8(avalue));
end;

method twriter.writestring32(const avalue: string32);
begin
 writestring8(string8(avalue));
end;

method twriter.writeproperty(const instance: tpersistent;
               const propinfo: ppropertyrttity);
var
 k1: stringkindty;
begin
 if propinfo^.flags * [prf_readfield,prf_readproc] = [] then
  exit; //can not get data for writing
 end;
 writestr(string8(propinfo^.name));
 case propinfo^.proptype^.kind of
  rtk_integer:
   writeinteger(getordprop(instance,propinfo));
  rtk_string:
   k1:= pstringrttity(propinfo^.proptype)^.stringkind;
   case k1 of
    stk_byte:
     writebytestring(getbytestringprop(instance,propinfo));
    stk_8:
     writestring8(getstring8prop(instance,propinfo));
    stk_16:
     writestring16(getstring16prop(instance,propinfo));
    stk_32:
     writestring32(getstring32prop(instance,propinfo));
    else:
     writererror(sinvalidstringkind,[string8(propinfo^.name),
                                     getenumname(typeinfo(k1),ord(k1))])
   end;
  else:
   writererror(scannotwritepropertykind,[string8(propinfo^.name),
               getenumname(typeinfo(propinfo^.proptype^.kind),
                                          ord(propinfo^.proptype^.kind))]);
 end;
end;

method twriter.writeproperties(const instance: tpersistent);
var
 ar1: propertyrttiarty;
 p1,pe: pppropertyrttity;
begin
 ar1:= getproperties(instance);
 p1:= pointer(ar1);
 pe:= p1 + length(ar1);
 while p1 < pe do
  writeproperty(instance,p1^);
  inc(p1);
 end;
end;

end.
