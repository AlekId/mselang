//rtl_system
{ MSEpas Copyright (c) 2017 by Martin Schreiber

    See the file COPYING.MSE, included in this distribution,
    for details about the copyright.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
}
unit rtl_system;
//system functions, preliminary ad-hoc implementation
interface
uses
 rtl_base,rtl_libc,rtl_sysexceptions;

const
 invalidfilehandle = -1;
 
type
 filehandlety = int32;
 fileopenmodety = (fm_none,fm_read,fm_write,fm_readwrite,fm_create,fm_append);
 fileaccessmodety = (fa_denywrite,fa_denyread);
 fileaccessmodesty = set of fileaccessmodety;
 filerightty = (s_irusr,s_iwusr,s_ixusr,
                s_irgrp,s_iwgrp,s_ixgrp,
                s_iroth,s_iwoth,s_ixoth,
                s_isuid,s_isgid,s_isvtx);
 filerightsty = set of filerightty;
 filetypety = (ft_unknown,ft_dir,ft_blk,ft_chr,ft_reg,ft_lnk,ft_sock,ft_fifo);
 fileattributety = (fa_rusr,fa_wusr,fa_xusr,
                    fa_rgrp,fa_wgrp,fa_xgrp,
                    fa_roth,fa_woth,fa_xoth,
                    fa_suid,fa_sgid,fa_svtx,
                    fa_dir,
                    fa_archive,fa_compressed,fa_encrypted,fa_hidden,
                    fa_offline,fa_reparsepoint,fa_sparsefile,fa_system,
                    fa_temporary,
                    fa_all);
 fileattributesty = set of fileattributety;
 accessmodety = (am_read,am_write,am_execute,am_exist);
 accessmodesty = set of accessmodety;
 seekoriginty = (so_beginning, so_current, so_end);

 syserrorty = (sye_ok,sye_lasterror,sye_extendederror,sye_busy,sye_dirstream,
                sye_network,sye_write,sye_read,
                sye_thread,sye_mutex,sye_semaphore,sye_cond,sye_timeout,
                sye_copyfile,sye_createdir,sye_noconsole,sye_notimplemented,
                sye_sockaddr,sye_socket,sye_isdir
               );

 esys = class(eerror)
  constructor create(aerror: syserrorty; atext: string);
  property error: syserrorty read geterror;
  private
   procedure geterror(): syserrorty;
 end;

procedure syelasterror: syserrorty; //returns sye_lasterror, sets mselasterror

procedure nowutc(): datetimety;



procedure syserror(const aerror: syserrorty; const message: string8);

var //todo: threadvar
 mselasterror: int32;
 
implementation
//{$internaldebug on}
//uses                           //todo: error with llvm debuginfo:
// rtl_libc;                     //"Unable to find compile unit!"
                                 //must be in interface
  
const
 unidatetimeoffset = -25569;

procedure syelasterror: syserrorty; //returns sye_lasterror, sets mselasterror
begin
 result:= sye_lasterror;
 mselasterror:= sys_getlasterror();
end;

procedure syserror(const aerror: syserrorty; const message: string8);
begin
 if aerror <> sye_ok then
  raise esys.create(error,buildsyserrormessage(error,text));
 end;
end;

procedure nowutc(): datetimety;
var
 ti: timeval;
 f1,f2: flo64;
begin
 gettimeofday(@ti,nil);
 result:= ti.tv_sec / (flo64(24.0)*60.0*60.0) + 
          ti.tv_usec / (flo64(24.0)*60.0*60.0*1e6) - unidatetimeoffset;
end;
(*
const
 openmodes: array[fileopenmodety] of longword =
//    fm_none,fm_read, fm_write,fm_readwrite,fm_create,
     (0,      o_rdonly,o_wronly,o_rdwr,      o_rdwr or o_creat or o_trunc,
//    fm_append
      o_rdwr or o_creat {or o_trunc});
*)

{ esys }

constructor esys.create(aerror: syserrorty;  atext: string);
begin
 inherited create(integer(aerror),atext,errortexts);
end;

function esys.geterror: syserrorty;
begin
 result:= syserrorty(ferror);
end;

end.