program pointertostring1;
//uses
// __mla__internaltypes;
// rttikindty = (rtk_none,rtk_enum,rtk_enumitem,rtk_object);

type
 allocsinfoty = record
  size: int32;
  instanceinterfacestart: int32; //offset in instance record
  classdefinterfacestart: int32; //offset in classdefheaderty
 end;

{$ifdef mse_compiler}
 pclassdefinfoty = targetptrintty;
 classdefinfopoty = ^classdefinfoty;
 classprocty = targetptrintty;
{$else}
 pclassdefinfoty = ^classdefinfoty;
 ppclassdefinfoty = ^pclassdefinfoty;
 procpoty = pointer;
 classprocty = procedure(instance: pointer);
{$endif}

 classdefprocty = (cdp_ini,cdp_fini,cdp_destruct);

 classdefheaderty = record 
   //layout fix, used in compiler llvmlists.tconsthashdatalist.addclassdef()
  parentclass: pclassdefinfoty;
  interfaceparent: pclassdefinfoty; //last parent class with interfaces
  virttaboffset: int32;             //field offset in instance
  typeinfo: pointer;//prttity;
  procs: array[classdefprocty] of classprocty;
  allocs: allocsinfoty;
 end;
 pclassdefheaderty = ^classdefheaderty;
 
 classdefinfoty = record
  header: classdefheaderty;
  virtualmethods: record //array of targetpointer to sub
  end;
  interfaces: record     //array of targetpointer to intfdefinfoty,
                         //copied to instance
  end;  
 end;



 ctest = class()[virtual]
  f1: int32;
  constructor create();
  destructor destroy();
 end;
 cty = class of ctest;

constructor ctest.create();
begin
end;

destructor ctest.destroy();
begin
end;

var
 cc1: cty;
 p1: pclassdefheaderty;
 c1: ctest;
begin
 cc1:= ctest;
 p1:= pointer(cc1);
 writeln(cc1,' ',p1^.allocs.size);
 c1:= ctest.create();
 c1.destroy();
// exitcode:= 123;
// p1:= pointer(cc1);
// c1:= ctest.create();
// p1:= c1.classinfo;
// writeln(p1);
// c1.destroy();
end.